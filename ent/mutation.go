// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/yigitsadic/wotblitz_example/ent/module"
	"github.com/yigitsadic/wotblitz_example/ent/predicate"
	"github.com/yigitsadic/wotblitz_example/ent/tank"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeModule = "Module"
	TypeTank   = "Tank"
)

// ModuleMutation represents an operation that mutate the Modules
// nodes in the graph.
type ModuleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	moduleType    *string
	createdAt     *time.Time
	clearedFields map[string]struct{}
	tanks         map[int]struct{}
	removedtanks  map[int]struct{}
	clearedtanks  bool
	done          bool
	oldValue      func(context.Context) (*Module, error)
	predicates    []predicate.Module
}

var _ ent.Mutation = (*ModuleMutation)(nil)

// moduleOption allows to manage the mutation configuration using functional options.
type moduleOption func(*ModuleMutation)

// newModuleMutation creates new mutation for Module.
func newModuleMutation(c config, op Op, opts ...moduleOption) *ModuleMutation {
	m := &ModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModuleID sets the id field of the mutation.
func withModuleID(id int) moduleOption {
	return func(m *ModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Module
		)
		m.oldValue = func(ctx context.Context) (*Module, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Module.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModule sets the old Module of the mutation.
func withModule(node *Module) moduleOption {
	return func(m *ModuleMutation) {
		m.oldValue = func(context.Context) (*Module, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ModuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ModuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ModuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Module.
// If the Module object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ModuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ModuleMutation) ResetName() {
	m.name = nil
}

// SetModuleType sets the moduleType field.
func (m *ModuleMutation) SetModuleType(s string) {
	m.moduleType = &s
}

// ModuleType returns the moduleType value in the mutation.
func (m *ModuleMutation) ModuleType() (r string, exists bool) {
	v := m.moduleType
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleType returns the old moduleType value of the Module.
// If the Module object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ModuleMutation) OldModuleType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldModuleType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldModuleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleType: %w", err)
	}
	return oldValue.ModuleType, nil
}

// ResetModuleType reset all changes of the "moduleType" field.
func (m *ModuleMutation) ResetModuleType() {
	m.moduleType = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ModuleMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ModuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Module.
// If the Module object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ModuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ModuleMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// AddTankIDs adds the tanks edge to Tank by ids.
func (m *ModuleMutation) AddTankIDs(ids ...int) {
	if m.tanks == nil {
		m.tanks = make(map[int]struct{})
	}
	for i := range ids {
		m.tanks[ids[i]] = struct{}{}
	}
}

// ClearTanks clears the tanks edge to Tank.
func (m *ModuleMutation) ClearTanks() {
	m.clearedtanks = true
}

// TanksCleared returns if the edge tanks was cleared.
func (m *ModuleMutation) TanksCleared() bool {
	return m.clearedtanks
}

// RemoveTankIDs removes the tanks edge to Tank by ids.
func (m *ModuleMutation) RemoveTankIDs(ids ...int) {
	if m.removedtanks == nil {
		m.removedtanks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtanks[ids[i]] = struct{}{}
	}
}

// RemovedTanks returns the removed ids of tanks.
func (m *ModuleMutation) RemovedTanksIDs() (ids []int) {
	for id := range m.removedtanks {
		ids = append(ids, id)
	}
	return
}

// TanksIDs returns the tanks ids in the mutation.
func (m *ModuleMutation) TanksIDs() (ids []int) {
	for id := range m.tanks {
		ids = append(ids, id)
	}
	return
}

// ResetTanks reset all changes of the "tanks" edge.
func (m *ModuleMutation) ResetTanks() {
	m.tanks = nil
	m.clearedtanks = false
	m.removedtanks = nil
}

// Op returns the operation name.
func (m *ModuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Module).
func (m *ModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ModuleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, module.FieldName)
	}
	if m.moduleType != nil {
		fields = append(fields, module.FieldModuleType)
	}
	if m.createdAt != nil {
		fields = append(fields, module.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ModuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case module.FieldName:
		return m.Name()
	case module.FieldModuleType:
		return m.ModuleType()
	case module.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case module.FieldName:
		return m.OldName(ctx)
	case module.FieldModuleType:
		return m.OldModuleType(ctx)
	case module.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Module field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case module.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case module.FieldModuleType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleType(v)
		return nil
	case module.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Module field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ModuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ModuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ModuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Module numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ModuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Module nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ModuleMutation) ResetField(name string) error {
	switch name {
	case module.FieldName:
		m.ResetName()
		return nil
	case module.FieldModuleType:
		m.ResetModuleType()
		return nil
	case module.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Module field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tanks != nil {
		edges = append(edges, module.EdgeTanks)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ModuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case module.EdgeTanks:
		ids := make([]ent.Value, 0, len(m.tanks))
		for id := range m.tanks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtanks != nil {
		edges = append(edges, module.EdgeTanks)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ModuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case module.EdgeTanks:
		ids := make([]ent.Value, 0, len(m.removedtanks))
		for id := range m.removedtanks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtanks {
		edges = append(edges, module.EdgeTanks)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ModuleMutation) EdgeCleared(name string) bool {
	switch name {
	case module.EdgeTanks:
		return m.clearedtanks
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ModuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Module unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ModuleMutation) ResetEdge(name string) error {
	switch name {
	case module.EdgeTanks:
		m.ResetTanks()
		return nil
	}
	return fmt.Errorf("unknown Module edge %s", name)
}

// TankMutation represents an operation that mutate the Tanks
// nodes in the graph.
type TankMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	tier                 *int
	addtier              *int
	isPremium            *bool
	tankClass            *string
	country              *string
	createdAt            *time.Time
	clearedFields        map[string]struct{}
	fromTankId           map[int]struct{}
	removedfromTankId    map[int]struct{}
	clearedfromTankId    bool
	nextTanks            map[int]struct{}
	removednextTanks     map[int]struct{}
	clearednextTanks     bool
	nextTankId           map[int]struct{}
	removednextTankId    map[int]struct{}
	clearednextTankId    bool
	previousTanks        map[int]struct{}
	removedpreviousTanks map[int]struct{}
	clearedpreviousTanks bool
	modules              map[int]struct{}
	removedmodules       map[int]struct{}
	clearedmodules       bool
	done                 bool
	oldValue             func(context.Context) (*Tank, error)
	predicates           []predicate.Tank
}

var _ ent.Mutation = (*TankMutation)(nil)

// tankOption allows to manage the mutation configuration using functional options.
type tankOption func(*TankMutation)

// newTankMutation creates new mutation for Tank.
func newTankMutation(c config, op Op, opts ...tankOption) *TankMutation {
	m := &TankMutation{
		config:        c,
		op:            op,
		typ:           TypeTank,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTankID sets the id field of the mutation.
func withTankID(id int) tankOption {
	return func(m *TankMutation) {
		var (
			err   error
			once  sync.Once
			value *Tank
		)
		m.oldValue = func(ctx context.Context) (*Tank, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tank.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTank sets the old Tank of the mutation.
func withTank(node *Tank) tankOption {
	return func(m *TankMutation) {
		m.oldValue = func(context.Context) (*Tank, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TankMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TankMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TankMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *TankMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TankMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Tank.
// If the Tank object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TankMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TankMutation) ResetName() {
	m.name = nil
}

// SetTier sets the tier field.
func (m *TankMutation) SetTier(i int) {
	m.tier = &i
	m.addtier = nil
}

// Tier returns the tier value in the mutation.
func (m *TankMutation) Tier() (r int, exists bool) {
	v := m.tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old tier value of the Tank.
// If the Tank object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TankMutation) OldTier(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTier is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// AddTier adds i to tier.
func (m *TankMutation) AddTier(i int) {
	if m.addtier != nil {
		*m.addtier += i
	} else {
		m.addtier = &i
	}
}

// AddedTier returns the value that was added to the tier field in this mutation.
func (m *TankMutation) AddedTier() (r int, exists bool) {
	v := m.addtier
	if v == nil {
		return
	}
	return *v, true
}

// ResetTier reset all changes of the "tier" field.
func (m *TankMutation) ResetTier() {
	m.tier = nil
	m.addtier = nil
}

// SetIsPremium sets the isPremium field.
func (m *TankMutation) SetIsPremium(b bool) {
	m.isPremium = &b
}

// IsPremium returns the isPremium value in the mutation.
func (m *TankMutation) IsPremium() (r bool, exists bool) {
	v := m.isPremium
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPremium returns the old isPremium value of the Tank.
// If the Tank object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TankMutation) OldIsPremium(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsPremium is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsPremium requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPremium: %w", err)
	}
	return oldValue.IsPremium, nil
}

// ResetIsPremium reset all changes of the "isPremium" field.
func (m *TankMutation) ResetIsPremium() {
	m.isPremium = nil
}

// SetTankClass sets the tankClass field.
func (m *TankMutation) SetTankClass(s string) {
	m.tankClass = &s
}

// TankClass returns the tankClass value in the mutation.
func (m *TankMutation) TankClass() (r string, exists bool) {
	v := m.tankClass
	if v == nil {
		return
	}
	return *v, true
}

// OldTankClass returns the old tankClass value of the Tank.
// If the Tank object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TankMutation) OldTankClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTankClass is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTankClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTankClass: %w", err)
	}
	return oldValue.TankClass, nil
}

// ResetTankClass reset all changes of the "tankClass" field.
func (m *TankMutation) ResetTankClass() {
	m.tankClass = nil
}

// SetCountry sets the country field.
func (m *TankMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the country value in the mutation.
func (m *TankMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old country value of the Tank.
// If the Tank object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TankMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCountry is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry reset all changes of the "country" field.
func (m *TankMutation) ResetCountry() {
	m.country = nil
}

// SetCreatedAt sets the createdAt field.
func (m *TankMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the createdAt value in the mutation.
func (m *TankMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Tank.
// If the Tank object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TankMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *TankMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// AddFromTankIdIDs adds the fromTankId edge to Tank by ids.
func (m *TankMutation) AddFromTankIdIDs(ids ...int) {
	if m.fromTankId == nil {
		m.fromTankId = make(map[int]struct{})
	}
	for i := range ids {
		m.fromTankId[ids[i]] = struct{}{}
	}
}

// ClearFromTankId clears the fromTankId edge to Tank.
func (m *TankMutation) ClearFromTankId() {
	m.clearedfromTankId = true
}

// FromTankIdCleared returns if the edge fromTankId was cleared.
func (m *TankMutation) FromTankIdCleared() bool {
	return m.clearedfromTankId
}

// RemoveFromTankIdIDs removes the fromTankId edge to Tank by ids.
func (m *TankMutation) RemoveFromTankIdIDs(ids ...int) {
	if m.removedfromTankId == nil {
		m.removedfromTankId = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfromTankId[ids[i]] = struct{}{}
	}
}

// RemovedFromTankId returns the removed ids of fromTankId.
func (m *TankMutation) RemovedFromTankIdIDs() (ids []int) {
	for id := range m.removedfromTankId {
		ids = append(ids, id)
	}
	return
}

// FromTankIdIDs returns the fromTankId ids in the mutation.
func (m *TankMutation) FromTankIdIDs() (ids []int) {
	for id := range m.fromTankId {
		ids = append(ids, id)
	}
	return
}

// ResetFromTankId reset all changes of the "fromTankId" edge.
func (m *TankMutation) ResetFromTankId() {
	m.fromTankId = nil
	m.clearedfromTankId = false
	m.removedfromTankId = nil
}

// AddNextTankIDs adds the nextTanks edge to Tank by ids.
func (m *TankMutation) AddNextTankIDs(ids ...int) {
	if m.nextTanks == nil {
		m.nextTanks = make(map[int]struct{})
	}
	for i := range ids {
		m.nextTanks[ids[i]] = struct{}{}
	}
}

// ClearNextTanks clears the nextTanks edge to Tank.
func (m *TankMutation) ClearNextTanks() {
	m.clearednextTanks = true
}

// NextTanksCleared returns if the edge nextTanks was cleared.
func (m *TankMutation) NextTanksCleared() bool {
	return m.clearednextTanks
}

// RemoveNextTankIDs removes the nextTanks edge to Tank by ids.
func (m *TankMutation) RemoveNextTankIDs(ids ...int) {
	if m.removednextTanks == nil {
		m.removednextTanks = make(map[int]struct{})
	}
	for i := range ids {
		m.removednextTanks[ids[i]] = struct{}{}
	}
}

// RemovedNextTanks returns the removed ids of nextTanks.
func (m *TankMutation) RemovedNextTanksIDs() (ids []int) {
	for id := range m.removednextTanks {
		ids = append(ids, id)
	}
	return
}

// NextTanksIDs returns the nextTanks ids in the mutation.
func (m *TankMutation) NextTanksIDs() (ids []int) {
	for id := range m.nextTanks {
		ids = append(ids, id)
	}
	return
}

// ResetNextTanks reset all changes of the "nextTanks" edge.
func (m *TankMutation) ResetNextTanks() {
	m.nextTanks = nil
	m.clearednextTanks = false
	m.removednextTanks = nil
}

// AddNextTankIdIDs adds the nextTankId edge to Tank by ids.
func (m *TankMutation) AddNextTankIdIDs(ids ...int) {
	if m.nextTankId == nil {
		m.nextTankId = make(map[int]struct{})
	}
	for i := range ids {
		m.nextTankId[ids[i]] = struct{}{}
	}
}

// ClearNextTankId clears the nextTankId edge to Tank.
func (m *TankMutation) ClearNextTankId() {
	m.clearednextTankId = true
}

// NextTankIdCleared returns if the edge nextTankId was cleared.
func (m *TankMutation) NextTankIdCleared() bool {
	return m.clearednextTankId
}

// RemoveNextTankIdIDs removes the nextTankId edge to Tank by ids.
func (m *TankMutation) RemoveNextTankIdIDs(ids ...int) {
	if m.removednextTankId == nil {
		m.removednextTankId = make(map[int]struct{})
	}
	for i := range ids {
		m.removednextTankId[ids[i]] = struct{}{}
	}
}

// RemovedNextTankId returns the removed ids of nextTankId.
func (m *TankMutation) RemovedNextTankIdIDs() (ids []int) {
	for id := range m.removednextTankId {
		ids = append(ids, id)
	}
	return
}

// NextTankIdIDs returns the nextTankId ids in the mutation.
func (m *TankMutation) NextTankIdIDs() (ids []int) {
	for id := range m.nextTankId {
		ids = append(ids, id)
	}
	return
}

// ResetNextTankId reset all changes of the "nextTankId" edge.
func (m *TankMutation) ResetNextTankId() {
	m.nextTankId = nil
	m.clearednextTankId = false
	m.removednextTankId = nil
}

// AddPreviousTankIDs adds the previousTanks edge to Tank by ids.
func (m *TankMutation) AddPreviousTankIDs(ids ...int) {
	if m.previousTanks == nil {
		m.previousTanks = make(map[int]struct{})
	}
	for i := range ids {
		m.previousTanks[ids[i]] = struct{}{}
	}
}

// ClearPreviousTanks clears the previousTanks edge to Tank.
func (m *TankMutation) ClearPreviousTanks() {
	m.clearedpreviousTanks = true
}

// PreviousTanksCleared returns if the edge previousTanks was cleared.
func (m *TankMutation) PreviousTanksCleared() bool {
	return m.clearedpreviousTanks
}

// RemovePreviousTankIDs removes the previousTanks edge to Tank by ids.
func (m *TankMutation) RemovePreviousTankIDs(ids ...int) {
	if m.removedpreviousTanks == nil {
		m.removedpreviousTanks = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpreviousTanks[ids[i]] = struct{}{}
	}
}

// RemovedPreviousTanks returns the removed ids of previousTanks.
func (m *TankMutation) RemovedPreviousTanksIDs() (ids []int) {
	for id := range m.removedpreviousTanks {
		ids = append(ids, id)
	}
	return
}

// PreviousTanksIDs returns the previousTanks ids in the mutation.
func (m *TankMutation) PreviousTanksIDs() (ids []int) {
	for id := range m.previousTanks {
		ids = append(ids, id)
	}
	return
}

// ResetPreviousTanks reset all changes of the "previousTanks" edge.
func (m *TankMutation) ResetPreviousTanks() {
	m.previousTanks = nil
	m.clearedpreviousTanks = false
	m.removedpreviousTanks = nil
}

// AddModuleIDs adds the modules edge to Module by ids.
func (m *TankMutation) AddModuleIDs(ids ...int) {
	if m.modules == nil {
		m.modules = make(map[int]struct{})
	}
	for i := range ids {
		m.modules[ids[i]] = struct{}{}
	}
}

// ClearModules clears the modules edge to Module.
func (m *TankMutation) ClearModules() {
	m.clearedmodules = true
}

// ModulesCleared returns if the edge modules was cleared.
func (m *TankMutation) ModulesCleared() bool {
	return m.clearedmodules
}

// RemoveModuleIDs removes the modules edge to Module by ids.
func (m *TankMutation) RemoveModuleIDs(ids ...int) {
	if m.removedmodules == nil {
		m.removedmodules = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmodules[ids[i]] = struct{}{}
	}
}

// RemovedModules returns the removed ids of modules.
func (m *TankMutation) RemovedModulesIDs() (ids []int) {
	for id := range m.removedmodules {
		ids = append(ids, id)
	}
	return
}

// ModulesIDs returns the modules ids in the mutation.
func (m *TankMutation) ModulesIDs() (ids []int) {
	for id := range m.modules {
		ids = append(ids, id)
	}
	return
}

// ResetModules reset all changes of the "modules" edge.
func (m *TankMutation) ResetModules() {
	m.modules = nil
	m.clearedmodules = false
	m.removedmodules = nil
}

// Op returns the operation name.
func (m *TankMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tank).
func (m *TankMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TankMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, tank.FieldName)
	}
	if m.tier != nil {
		fields = append(fields, tank.FieldTier)
	}
	if m.isPremium != nil {
		fields = append(fields, tank.FieldIsPremium)
	}
	if m.tankClass != nil {
		fields = append(fields, tank.FieldTankClass)
	}
	if m.country != nil {
		fields = append(fields, tank.FieldCountry)
	}
	if m.createdAt != nil {
		fields = append(fields, tank.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TankMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tank.FieldName:
		return m.Name()
	case tank.FieldTier:
		return m.Tier()
	case tank.FieldIsPremium:
		return m.IsPremium()
	case tank.FieldTankClass:
		return m.TankClass()
	case tank.FieldCountry:
		return m.Country()
	case tank.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TankMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tank.FieldName:
		return m.OldName(ctx)
	case tank.FieldTier:
		return m.OldTier(ctx)
	case tank.FieldIsPremium:
		return m.OldIsPremium(ctx)
	case tank.FieldTankClass:
		return m.OldTankClass(ctx)
	case tank.FieldCountry:
		return m.OldCountry(ctx)
	case tank.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tank field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TankMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tank.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tank.FieldTier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case tank.FieldIsPremium:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPremium(v)
		return nil
	case tank.FieldTankClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTankClass(v)
		return nil
	case tank.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case tank.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tank field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TankMutation) AddedFields() []string {
	var fields []string
	if m.addtier != nil {
		fields = append(fields, tank.FieldTier)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TankMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tank.FieldTier:
		return m.AddedTier()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TankMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tank.FieldTier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTier(v)
		return nil
	}
	return fmt.Errorf("unknown Tank numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TankMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TankMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TankMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tank nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TankMutation) ResetField(name string) error {
	switch name {
	case tank.FieldName:
		m.ResetName()
		return nil
	case tank.FieldTier:
		m.ResetTier()
		return nil
	case tank.FieldIsPremium:
		m.ResetIsPremium()
		return nil
	case tank.FieldTankClass:
		m.ResetTankClass()
		return nil
	case tank.FieldCountry:
		m.ResetCountry()
		return nil
	case tank.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tank field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TankMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.fromTankId != nil {
		edges = append(edges, tank.EdgeFromTankId)
	}
	if m.nextTanks != nil {
		edges = append(edges, tank.EdgeNextTanks)
	}
	if m.nextTankId != nil {
		edges = append(edges, tank.EdgeNextTankId)
	}
	if m.previousTanks != nil {
		edges = append(edges, tank.EdgePreviousTanks)
	}
	if m.modules != nil {
		edges = append(edges, tank.EdgeModules)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TankMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tank.EdgeFromTankId:
		ids := make([]ent.Value, 0, len(m.fromTankId))
		for id := range m.fromTankId {
			ids = append(ids, id)
		}
		return ids
	case tank.EdgeNextTanks:
		ids := make([]ent.Value, 0, len(m.nextTanks))
		for id := range m.nextTanks {
			ids = append(ids, id)
		}
		return ids
	case tank.EdgeNextTankId:
		ids := make([]ent.Value, 0, len(m.nextTankId))
		for id := range m.nextTankId {
			ids = append(ids, id)
		}
		return ids
	case tank.EdgePreviousTanks:
		ids := make([]ent.Value, 0, len(m.previousTanks))
		for id := range m.previousTanks {
			ids = append(ids, id)
		}
		return ids
	case tank.EdgeModules:
		ids := make([]ent.Value, 0, len(m.modules))
		for id := range m.modules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TankMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedfromTankId != nil {
		edges = append(edges, tank.EdgeFromTankId)
	}
	if m.removednextTanks != nil {
		edges = append(edges, tank.EdgeNextTanks)
	}
	if m.removednextTankId != nil {
		edges = append(edges, tank.EdgeNextTankId)
	}
	if m.removedpreviousTanks != nil {
		edges = append(edges, tank.EdgePreviousTanks)
	}
	if m.removedmodules != nil {
		edges = append(edges, tank.EdgeModules)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TankMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tank.EdgeFromTankId:
		ids := make([]ent.Value, 0, len(m.removedfromTankId))
		for id := range m.removedfromTankId {
			ids = append(ids, id)
		}
		return ids
	case tank.EdgeNextTanks:
		ids := make([]ent.Value, 0, len(m.removednextTanks))
		for id := range m.removednextTanks {
			ids = append(ids, id)
		}
		return ids
	case tank.EdgeNextTankId:
		ids := make([]ent.Value, 0, len(m.removednextTankId))
		for id := range m.removednextTankId {
			ids = append(ids, id)
		}
		return ids
	case tank.EdgePreviousTanks:
		ids := make([]ent.Value, 0, len(m.removedpreviousTanks))
		for id := range m.removedpreviousTanks {
			ids = append(ids, id)
		}
		return ids
	case tank.EdgeModules:
		ids := make([]ent.Value, 0, len(m.removedmodules))
		for id := range m.removedmodules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TankMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedfromTankId {
		edges = append(edges, tank.EdgeFromTankId)
	}
	if m.clearednextTanks {
		edges = append(edges, tank.EdgeNextTanks)
	}
	if m.clearednextTankId {
		edges = append(edges, tank.EdgeNextTankId)
	}
	if m.clearedpreviousTanks {
		edges = append(edges, tank.EdgePreviousTanks)
	}
	if m.clearedmodules {
		edges = append(edges, tank.EdgeModules)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TankMutation) EdgeCleared(name string) bool {
	switch name {
	case tank.EdgeFromTankId:
		return m.clearedfromTankId
	case tank.EdgeNextTanks:
		return m.clearednextTanks
	case tank.EdgeNextTankId:
		return m.clearednextTankId
	case tank.EdgePreviousTanks:
		return m.clearedpreviousTanks
	case tank.EdgeModules:
		return m.clearedmodules
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TankMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tank unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TankMutation) ResetEdge(name string) error {
	switch name {
	case tank.EdgeFromTankId:
		m.ResetFromTankId()
		return nil
	case tank.EdgeNextTanks:
		m.ResetNextTanks()
		return nil
	case tank.EdgeNextTankId:
		m.ResetNextTankId()
		return nil
	case tank.EdgePreviousTanks:
		m.ResetPreviousTanks()
		return nil
	case tank.EdgeModules:
		m.ResetModules()
		return nil
	}
	return fmt.Errorf("unknown Tank edge %s", name)
}
